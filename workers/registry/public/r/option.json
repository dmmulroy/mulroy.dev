{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "option",
  "type": "registry:lib",
  "title": "Option",
  "description": "Option type for representing optional values without null/undefined",
  "files": [
    {
      "path": "registry/default/lib/option.ts",
      "content": "/**\n * Option type for representing optional values without null/undefined.\n *\n * @example\n * ```typescript\n * const option = Option.some(42)\n *   .map(x => x * 2)\n *   .filter(x => x > 50);\n *\n * if (option.isSome()) {\n *   console.log(option.value);\n * } else {\n *   console.log(\"no value\");\n * }\n * ```\n */\n\nexport type Option<T> = Some<T> | None<T>;\n\n/**\n * Some variant of Option containing a value.\n *\n * @template T - The value type\n */\nexport class Some<T> {\n  readonly _tag = \"Some\" as const;\n  constructor(readonly value: T) {}\n\n  /**\n   * Type guard for Some variant.\n   *\n   * @returns true\n   */\n  isSome(): this is Some<T> {\n    return true;\n  }\n\n  /**\n   * Type guard for None variant.\n   *\n   * @returns false\n   */\n  isNone(): this is None<T> {\n    return false;\n  }\n\n  /**\n   * Transform the value.\n   *\n   * @param fn - Transform function\n   * @returns New Option with transformed value\n   */\n  map<U>(fn: (value: T) => U): Option<U> {\n    return new Some(fn(this.value));\n  }\n\n  /**\n   * Chain an Option-returning function.\n   *\n   * @param fn - Function returning a new Option\n   * @returns Option from fn\n   */\n  andThen<U>(fn: (value: T) => Option<U>): Option<U> {\n    return fn(this.value);\n  }\n\n  /**\n   * Return alternative if None. No-op for Some.\n   *\n   * @param _fn - Function returning alternative (not called)\n   * @returns This Some\n   */\n  orElse(_fn: () => Option<T>): Option<T> {\n    return this;\n  }\n\n  /**\n   * Filter the value by predicate.\n   *\n   * @param predicate - Predicate function\n   * @returns Some if predicate passes, None otherwise\n   */\n  filter(predicate: (value: T) => boolean): Option<T> {\n    return predicate(this.value) ? this : none();\n  }\n\n  /**\n   * Extract value.\n   *\n   * @returns The value\n   */\n  unwrap(): T {\n    return this.value;\n  }\n\n  /**\n   * Extract value or return default.\n   *\n   * @param _defaultValue - Default value (not used)\n   * @returns The value\n   */\n  unwrapOr(_defaultValue: T): T {\n    return this.value;\n  }\n\n  /**\n   * Extract value or compute default.\n   *\n   * @param _fn - Function to compute default (not called)\n   * @returns The value\n   */\n  unwrapOrElse(_fn: () => T): T {\n    return this.value;\n  }\n\n  /**\n   * Pattern match on Option.\n   *\n   * @param handlers - Object with some and none handlers\n   * @returns Result of some handler\n   */\n  match<U>(handlers: { some: (value: T) => U; none: () => U }): U {\n    return handlers.some(this.value);\n  }\n\n  /**\n   * Convert to nullable.\n   *\n   * @returns The value\n   */\n  toNullable(): T | null {\n    return this.value;\n  }\n\n  /**\n   * Zip with another Option.\n   *\n   * @param other - Another Option\n   * @returns Some with tuple if both are Some, None otherwise\n   */\n  zip<U>(other: Option<U>): Option<[T, U]> {\n    return other.isSome() ? some([this.value, other.value]) : none();\n  }\n}\n\n// SAFETY: None has no runtime value. The `T` type parameter is phantom (unused at runtime).\n// Casting None<T> to None<U> is safe because T has no runtime representation.\n/**\n * None variant of Option representing absence of value.\n *\n * @template T - The value type (phantom, unused at runtime)\n */\nexport class None<T> {\n  readonly _tag = \"None\" as const;\n\n  /**\n   * Type guard for Some variant.\n   *\n   * @returns false\n   */\n  isSome(): this is Some<T> {\n    return false;\n  }\n\n  /**\n   * Type guard for None variant.\n   *\n   * @returns true\n   */\n  isNone(): this is None<T> {\n    return true;\n  }\n\n  /**\n   * Transform the value. No-op for None.\n   *\n   * @param _fn - Transform function (not called)\n   * @returns This None with new type\n   */\n  map<U>(_fn: (value: T) => U): Option<U> {\n    // SAFETY: T is phantom in None; see class comment\n    return this as unknown as None<U>;\n  }\n\n  /**\n   * Chain an Option-returning function. No-op for None.\n   *\n   * @param _fn - Function returning a new Option (not called)\n   * @returns This None with new type\n   */\n  andThen<U>(_fn: (value: T) => Option<U>): Option<U> {\n    // SAFETY: T is phantom in None; see class comment\n    return this as unknown as None<U>;\n  }\n\n  /**\n   * Return alternative if None.\n   *\n   * @param fn - Function returning alternative\n   * @returns Option from fn\n   */\n  orElse(fn: () => Option<T>): Option<T> {\n    return fn();\n  }\n\n  /**\n   * Filter the value by predicate. No-op for None.\n   *\n   * @param _predicate - Predicate function (not called)\n   * @returns This None\n   */\n  filter(_predicate: (value: T) => boolean): Option<T> {\n    return this;\n  }\n\n  /**\n   * Extract value.\n   *\n   * @throws Error always (None has no value)\n   */\n  unwrap(): T {\n    throw new Error(\"Called unwrap on None\");\n  }\n\n  /**\n   * Extract value or return default.\n   *\n   * @param defaultValue - Default value to return\n   * @returns The default value\n   */\n  unwrapOr(defaultValue: T): T {\n    return defaultValue;\n  }\n\n  /**\n   * Extract value or compute default.\n   *\n   * @param fn - Function to compute default\n   * @returns The computed default\n   */\n  unwrapOrElse(fn: () => T): T {\n    return fn();\n  }\n\n  /**\n   * Pattern match on Option.\n   *\n   * @param handlers - Object with some and none handlers\n   * @returns Result of none handler\n   */\n  match<U>(handlers: { some: (value: T) => U; none: () => U }): U {\n    return handlers.none();\n  }\n\n  /**\n   * Convert to nullable.\n   *\n   * @returns null\n   */\n  toNullable(): T | null {\n    return null;\n  }\n\n  /**\n   * Zip with another Option. No-op for None.\n   *\n   * @param _other - Another Option (not used)\n   * @returns This None with tuple type\n   */\n  zip<U>(_other: Option<U>): Option<[T, U]> {\n    // SAFETY: T is phantom in None; see class comment\n    return this as unknown as None<[T, U]>;\n  }\n}\n\n// Singleton None instance for reuse\nconst NONE = new None<never>();\n\n/**\n * Create a Some Option.\n *\n * @param value - The value\n * @returns Some containing value\n *\n * @example\n * ```typescript\n * const option = Option.some(42);\n * ```\n */\nfunction some<T>(value: T): Option<T> {\n  return new Some(value);\n}\n\n/**\n * Create a None Option.\n *\n * @returns None\n *\n * @example\n * ```typescript\n * const option = Option.none<number>();\n * ```\n */\nfunction none<T = never>(): Option<T> {\n  return NONE as Option<T>;\n}\n\n/**\n * Create Option from nullable value.\n *\n * @param value - Value that may be null or undefined\n * @returns Some if value exists, None otherwise\n *\n * @example\n * ```typescript\n * const option = Option.fromNullable(maybeValue);\n * ```\n */\nfunction fromNullable<T>(value: T | null | undefined): Option<T> {\n  return value == null ? none() : some(value);\n}\n\n/**\n * Create Option from predicate.\n *\n * @param value - Value to test\n * @param predicate - Predicate function\n * @returns Some if predicate passes, None otherwise\n *\n * @example\n * ```typescript\n * const option = Option.fromPredicate(5, x => x > 0);\n * ```\n */\nfunction fromPredicate<T>(value: T, predicate: (value: T) => boolean): Option<T> {\n  return predicate(value) ? some(value) : none();\n}\n\n/**\n * Convert array of Options to Option of array. Fails on first None.\n *\n * @param options - Array of Options\n * @returns Some with array of values or None if any is None\n *\n * @example\n * ```typescript\n * const options = [Option.some(1), Option.some(2), Option.some(3)];\n * const combined = Option.all(options); // Some([1, 2, 3])\n * ```\n */\nfunction all<T>(options: Option<T>[]): Option<T[]> {\n  const values: T[] = [];\n  for (const option of options) {\n    if (option.isNone()) {\n      // SAFETY: T is phantom in None; None<T> and None<T[]> are identical at runtime\n      return option as unknown as None<T[]>;\n    }\n    values.push(option.value);\n  }\n  return some(values);\n}\n\n/**\n * Return first Some or None from array of Options.\n *\n * @param options - Array of Options\n * @returns First Some found or None if all are None\n *\n * @example\n * ```typescript\n * const options = [Option.none(), Option.some(42), Option.none()];\n * const first = Option.firstSome(options); // Some(42)\n * ```\n */\nfunction firstSome<T>(options: Option<T>[]): Option<T> {\n  for (const option of options) {\n    if (option.isSome()) {\n      return option;\n    }\n  }\n  return none();\n}\n\nexport const Option = {\n  some,\n  none,\n  fromNullable,\n  fromPredicate,\n  all,\n  firstSome,\n} as const;\n",
      "type": "registry:lib"
    }
  ]
}