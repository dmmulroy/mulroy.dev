{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "result",
  "type": "registry:lib",
  "title": "Result",
  "description": "Result type for typed error handling without exceptions",
  "files": [
    {
      "path": "registry/default/lib/result.ts",
      "content": "/**\n * Result type for typed error handling without exceptions.\n *\n * @example\n * ```typescript\n * const result = Result.ok(42)\n *   .map(x => x * 2)\n *   .andThen(x => x > 50 ? Result.ok(x) : Result.err(\"too small\"));\n *\n * if (result.isOk()) {\n *   console.log(result.value);\n * } else {\n *   console.log(result.error);\n * }\n * ```\n */\n\nexport type Result<T, E> = Ok<T, E> | Err<T, E>;\n\n// SAFETY: Ok only stores `value: T`. The `E` type parameter is phantom (unused at runtime).\n// Casting Ok<T, E> to Ok<T, F> is safe because E has no runtime representation.\n/**\n * Success variant of Result.\n *\n * @template T - The success value type\n * @template E - The error type (phantom, unused at runtime)\n */\nexport class Ok<T, E> {\n  readonly _tag = \"Ok\" as const;\n  constructor(readonly value: T) {}\n\n  /**\n   * Type guard for Ok variant.\n   *\n   * @returns true\n   */\n  isOk(): this is Ok<T, E> {\n    return true;\n  }\n\n  /**\n   * Type guard for Err variant.\n   *\n   * @returns false\n   */\n  isErr(): this is Err<T, E> {\n    return false;\n  }\n\n  /**\n   * Transform the success value.\n   *\n   * @param fn - Transform function\n   * @returns New Result with transformed value\n   */\n  map<U>(fn: (value: T) => U): Result<U, E> {\n    return new Ok(fn(this.value));\n  }\n\n  /**\n   * Transform the error value. No-op for Ok.\n   *\n   * @param _fn - Transform function (not called)\n   * @returns This Ok with new error type\n   */\n  mapErr<F>(_fn: (error: E) => F): Result<T, F> {\n    // SAFETY: E is phantom in Ok; see class comment\n    return this as unknown as Ok<T, F>;\n  }\n\n  /**\n   * Chain a Result-returning function on success.\n   *\n   * @param fn - Function returning a new Result\n   * @returns Result from fn\n   */\n  andThen<U, F>(fn: (value: T) => Result<U, F>): Result<U, E | F> {\n    return fn(this.value);\n  }\n\n  /**\n   * Recover from error with a Result-returning function. No-op for Ok.\n   *\n   * @param _fn - Recovery function (not called)\n   * @returns This Ok with new error type\n   */\n  orElse<F>(_fn: (error: E) => Result<T, F>): Result<T, F> {\n    // SAFETY: E is phantom in Ok; see class comment\n    return this as unknown as Ok<T, F>;\n  }\n\n  /**\n   * Extract success value.\n   *\n   * @returns The success value\n   */\n  unwrap(): T {\n    return this.value;\n  }\n\n  /**\n   * Extract success value or return default.\n   *\n   * @param _defaultValue - Default value (not used)\n   * @returns The success value\n   */\n  unwrapOr(_defaultValue: T): T {\n    return this.value;\n  }\n\n  /**\n   * Extract error value.\n   *\n   * @throws Error always (Ok has no error)\n   */\n  unwrapErr(): E {\n    throw new Error(\"Called unwrapErr on Ok\");\n  }\n\n  /**\n   * Pattern match on Result.\n   *\n   * @param handlers - Object with ok and err handlers\n   * @returns Result of ok handler\n   */\n  match<U>(handlers: { ok: (value: T) => U; err: (error: E) => U }): U {\n    return handlers.ok(this.value);\n  }\n}\n\n// SAFETY: Err only stores `error: E`. The `T` type parameter is phantom (unused at runtime).\n// Casting Err<T, E> to Err<U, E> is safe because T has no runtime representation.\n/**\n * Failure variant of Result.\n *\n * @template T - The success type (phantom, unused at runtime)\n * @template E - The error value type\n */\nexport class Err<T, E> {\n  readonly _tag = \"Err\" as const;\n  constructor(readonly error: E) {}\n\n  /**\n   * Type guard for Ok variant.\n   *\n   * @returns false\n   */\n  isOk(): this is Ok<T, E> {\n    return false;\n  }\n\n  /**\n   * Type guard for Err variant.\n   *\n   * @returns true\n   */\n  isErr(): this is Err<T, E> {\n    return true;\n  }\n\n  /**\n   * Transform the success value. No-op for Err.\n   *\n   * @param _fn - Transform function (not called)\n   * @returns This Err with new success type\n   */\n  map<U>(_fn: (value: T) => U): Result<U, E> {\n    // SAFETY: T is phantom in Err; see class comment\n    return this as unknown as Err<U, E>;\n  }\n\n  /**\n   * Transform the error value.\n   *\n   * @param fn - Transform function\n   * @returns New Err with transformed error\n   */\n  mapErr<F>(fn: (error: E) => F): Result<T, F> {\n    return new Err(fn(this.error));\n  }\n\n  /**\n   * Chain a Result-returning function on success. No-op for Err.\n   *\n   * @param _fn - Function returning a new Result (not called)\n   * @returns This Err with union error type\n   */\n  andThen<U, F>(_fn: (value: T) => Result<U, F>): Result<U, E | F> {\n    // SAFETY: T is phantom in Err; see class comment\n    return this as unknown as Err<U, E>;\n  }\n\n  /**\n   * Recover from error with a Result-returning function.\n   *\n   * @param fn - Recovery function\n   * @returns Result from fn\n   */\n  orElse<F>(fn: (error: E) => Result<T, F>): Result<T, F> {\n    return fn(this.error);\n  }\n\n  /**\n   * Extract success value.\n   *\n   * @throws Error always (Err has no success value)\n   */\n  unwrap(): T {\n    throw new Error(\"Called unwrap on Err\");\n  }\n\n  /**\n   * Extract success value or return default.\n   *\n   * @param defaultValue - Default value to return\n   * @returns The default value\n   */\n  unwrapOr(defaultValue: T): T {\n    return defaultValue;\n  }\n\n  /**\n   * Extract error value.\n   *\n   * @returns The error value\n   */\n  unwrapErr(): E {\n    return this.error;\n  }\n\n  /**\n   * Pattern match on Result.\n   *\n   * @param handlers - Object with ok and err handlers\n   * @returns Result of err handler\n   */\n  match<U>(handlers: { ok: (value: T) => U; err: (error: E) => U }): U {\n    return handlers.err(this.error);\n  }\n}\n\n/**\n * Create a success Result.\n *\n * @param value - The success value\n * @returns Ok containing value\n *\n * @example\n * ```typescript\n * const result = Result.ok(42);\n * ```\n */\nfunction ok<T, E = never>(value: T): Result<T, E> {\n  return new Ok(value);\n}\n\n/**\n * Create a failure Result.\n *\n * @param error - The error value\n * @returns Err containing error\n *\n * @example\n * ```typescript\n * const result = Result.err(\"not found\");\n * ```\n */\nfunction err<E, T = never>(error: E): Result<T, E> {\n  return new Err(error);\n}\n\n/**\n * Wrap a throwing function in a Result.\n *\n * @param fn - Function that may throw\n * @param onError - Transform caught value to error type\n * @returns Ok with return value or Err with transformed error\n *\n * @example\n * ```typescript\n * const result = Result.tryCatch(\n *   () => JSON.parse(input),\n *   (e) => new ParseError({ cause: e })\n * );\n * ```\n */\nfunction tryCatch<T, E = Error>(\n  fn: () => T,\n  onError: (e: unknown) => E = (e) => e as E,\n): Result<T, E> {\n  try {\n    return ok(fn());\n  } catch (e) {\n    return err(onError(e));\n  }\n}\n\n/**\n * Wrap an async throwing function in a Result.\n *\n * @param fn - Async function that may throw\n * @param onError - Transform caught value to error type\n * @returns Promise of Ok with return value or Err with transformed error\n *\n * @example\n * ```typescript\n * const result = await Result.tryCatchAsync(\n *   () => fetch(url).then(r => r.json()),\n *   (e) => new FetchError({ cause: e })\n * );\n * ```\n */\nasync function tryCatchAsync<T, E = Error>(\n  fn: () => Promise<T>,\n  onError: (e: unknown) => E = (e) => e as E,\n): Promise<Result<T, E>> {\n  try {\n    return ok(await fn());\n  } catch (e) {\n    return err(onError(e));\n  }\n}\n\n/**\n * Convert array of Results to Result of array. Fails on first error.\n *\n * @param results - Array of Results\n * @returns Ok with array of values or first Err encountered\n *\n * @example\n * ```typescript\n * const results = [Result.ok(1), Result.ok(2), Result.ok(3)];\n * const combined = Result.all(results); // Ok([1, 2, 3])\n * ```\n */\nfunction all<T, E>(results: Result<T, E>[]): Result<T[], E> {\n  const values: T[] = [];\n  for (const result of results) {\n    if (result.isErr()) {\n      // SAFETY: T is phantom in Err; Err<T, E> and Err<T[], E> are identical at runtime\n      return result as unknown as Err<T[], E>;\n    }\n    values.push(result.value);\n  }\n  return ok(values);\n}\n\n/**\n * Partition array of Results into [oks, errs].\n *\n * @param results - Array of Results\n * @returns Tuple of [ok values, error values]\n *\n * @example\n * ```typescript\n * const results = [Result.ok(1), Result.err(\"a\"), Result.ok(2), Result.err(\"b\")];\n * const [oks, errs] = Result.partition(results); // [[1, 2], [\"a\", \"b\"]]\n * ```\n */\nfunction partition<T, E>(results: Result<T, E>[]): [T[], E[]] {\n  const oks: T[] = [];\n  const errs: E[] = [];\n  for (const result of results) {\n    if (result.isErr()) {\n      errs.push(result.error);\n    } else {\n      oks.push(result.value);\n    }\n  }\n  return [oks, errs];\n}\n\n/**\n * Return first Ok or last Err from array of Results.\n *\n * @param results - Non-empty array of Results\n * @returns First Ok found or last Err if all fail\n * @throws Error if array is empty\n *\n * @example\n * ```typescript\n * const results = [Result.err(\"a\"), Result.ok(42), Result.err(\"b\")];\n * const first = Result.firstOk(results); // Ok(42)\n * ```\n */\nfunction firstOk<T, E>(results: Result<T, E>[]): Result<T, E> {\n  let lastErr: Result<T, E> | undefined;\n  for (const result of results) {\n    if (result.isOk()) {\n      return result;\n    }\n    lastErr = result;\n  }\n  if (lastErr) {\n    return lastErr;\n  }\n  throw new Error(\"firstOk called with empty array\");\n}\n\nexport const Result = {\n  ok,\n  err,\n  tryCatch,\n  tryCatchAsync,\n  all,\n  partition,\n  firstOk,\n} as const;\n",
      "type": "registry:lib"
    }
  ]
}