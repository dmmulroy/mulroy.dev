{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tagged-error",
  "type": "registry:lib",
  "title": "TaggedError",
  "description": "Mixin factory for discriminated error classes with typed props",
  "files": [
    {
      "path": "src/lib/tagged-error.ts",
      "content": "/**\n * Mixin factory for discriminated error classes with typed props.\n *\n * Props become readonly fields; `message`/`cause` auto-wire to Error; `cause.stack` chains.\n *\n * @see [TypeScript Mixins](https://www.typescriptlang.org/docs/handbook/mixins.html)\n * @typeParam Tag - Literal string for `_tag` discriminant\n * @returns Base class to extend with optional generic props\n *\n * @example\n * ```typescript\n * class CreateGitRepoError extends TaggedError(\"CreateGitRepoError\")<{\n *   repoName: string;\n *   org: string;\n *   cause?: Error;\n * }> {}\n *\n * const err = new CreateGitRepoError({ repoName: \"api\", org: \"acme\", cause: httpErr });\n * err._tag;    // \"CreateGitRepoError\" (literal)\n * err.repoName; // string (typed)\n * err.toJSON(); // serializable\n * ```\n */\nexport function TaggedError<Tag extends string>(\n  tag: Tag,\n): new <A extends Record<string, unknown> = {}>(\n  ...args: {} extends TaggedErrorProps<A>\n    ? [props?: TaggedErrorProps<A>]\n    : [props: TaggedErrorProps<A>]\n) => Error & {\n  readonly _tag: Tag;\n  toJSON(): Record<string, unknown>;\n  prettyPrint(): string;\n} & Readonly<A> {\n  const instances = new WeakMap<Error, Record<string, unknown>>();\n\n  class TaggedErrorClass extends Error {\n    readonly _tag: Tag = tag;\n    override readonly name = tag;\n\n    constructor(props?: Record<string, unknown>) {\n      const message = getMessage(tag, props);\n      const cause = getCause(props);\n      super(message, { cause });\n\n      if (props) {\n        Object.assign(this, props);\n        instances.set(this, props);\n      }\n\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, new.target);\n      }\n\n      if (cause) {\n        this.stack = `${this.stack}\\nCaused by: ${cause.stack}`;\n      }\n    }\n\n    toJSON(): Record<string, unknown> {\n      return {\n        _tag: this._tag,\n        message: this.message,\n        stack: this.stack,\n        ...instances.get(this),\n      };\n    }\n\n    [Symbol.for(\"nodejs.util.inspect.custom\")](): string {\n      return this.prettyPrint();\n    }\n\n    /** Formats error with tag, message, properties, and stack trace */\n    prettyPrint(): string {\n      const props = instances.get(this);\n      const propsStr = props\n        ? Object.entries(props)\n            .filter(([k]) => k !== \"message\" && k !== \"cause\")\n            .map(([k, v]) => `  ${k}: ${JSON.stringify(v)}`)\n            .join(\"\\n\")\n        : \"\";\n\n      let result = `${tag}: ${this.message}`;\n      if (propsStr) result += `\\n${propsStr}`;\n      if (this.stack) {\n        const stackLines = this.stack.split(\"\\n\").slice(1).join(\"\\n\");\n        if (stackLines) result += `\\n${stackLines}`;\n      }\n      return result;\n    }\n  }\n\n  // Cast required: internal class can't express the generic `Readonly<A>` constraint\n  // that gets applied per-instantiation. `never` is assignable to any type.\n  return TaggedErrorClass as never;\n}\n\ntype TaggedErrorProps<A extends Record<string, unknown>> = {\n  readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P];\n};\n\nfunction getMessage(tag: string, props?: Record<string, unknown>): string {\n  return props && \"message\" in props && typeof props.message === \"string\"\n    ? props.message\n    : tag;\n}\n\nfunction getCause(props?: Record<string, unknown>): Error | undefined {\n  return props && \"cause\" in props && Error.isError(props.cause)\n    ? props.cause\n    : undefined;\n}\n",
      "type": "registry:lib",
      "target": "lib/tagged-error.ts"
    }
  ]
}